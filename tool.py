import argparse 
import sys
import os
import json
import SimpleHTTPServer
import SocketServer
import threading
import readline
import sqlite3
import subprocess
import re
import requests
import shlex
import pexpect
from threading import Thread
from Queue import Queue

class ExitApplicationException(Exception):
  pass

class Settings:
  machine = ""
  network = ""
  pwd =  ""
  debug = False
  editor = None
  threads = None

  def __init__(self, machine="", network="", pwd="", debug=False, web_server_dir=None, threads=10, editor="/usr/bin/vim"):
    self.machine = machine
    self.network = network
    self.pwd = pwd
    self.debug = debug
    self.web_server_dir = web_server_dir
    self.editor = editor
    self.threads = threads

class ShellCommandRunner:
  SUBPROCESS = 1
  PEXPECT = 2

  output_list = []

  def __init__(self, method, output_list):
    self.method = method
    self.output_list = output_list

  def execute(self, cmd):
    shell_cmd = cmd.get()
    if not isinstance(shell_cmd.command, list):
      cmd = shlex.split(shell_cmd.command)
    else:
      cmd = shell_cmd.command

    status = None

    if self.method == self.SUBPROCESS:
      output_file = open(shell_cmd.output, "w") if shell_cmd.output else None
      c = subprocess.Popen(cmd, stdout=output_file)

      if shell_cmd.interactive:
        c.communicate()

      status = c.returncode

      if shell_cmd.output:
        if c.returncode != 0:
          with open(shell_cmd.output) as f:
            print f.read()

          os.remove(shell_cmd.output)


      if shell_cmd.completed:
        shell_cmd.completed(status)

    elif self.method == self.PEXPECT:
      child = pexpect.spawn("/bin/bash", ["-c", " ".join(cmd)])
      child.interact()

class ShellCommand:
  command = ""
  completed = None
  interactive = False
  output = None

  def __init__(self, command, output=None, interactive=False, completed=None):
    self.command = command
    self.interactive = interactive
    self.completed = completed
    self.output = output

  def get(self):
    return self
    
class Commands:
  settings = None
  env = None
  found = None

  web_server = {}

  command_runner = None
  command_queue = None

  def __init__(self, settings, env, command_runner):
    self.settings = settings
    self.env = env
    self.found = []
    self.command_runner = command_runner
    self.command_queue = Queue(maxsize=0)
    self.command_output = []

    for i in range(settings.threads):
      worker = Thread(target=command_runner.execute, args=(self.command_queue,))
      worker.setDaemon(True)
      worker.start()

    if not settings.network:
      self.settings.network = raw_input("Enter Network> ")

    if not settings.machine:
      self.settings.machine = raw_input("Enter Machine> ")

    self.do_network(settings.network)
    self.do_machine(settings.machine)

  def do_help(self, cmd):
    if cmd:
      details = {
        "machine": "machine <machine name>",
        "network": "network <network name",
        "tag": "tag <tag> <value>",
        "rtag": "rtag <tag>",
        "find": "tag <tag> <value>",
        "go": "go <found id|network/machine|machine>",
        "show": "show <loot|settings|files|tags|machines|networks|scan|notes|svr>",
        "scan": "scan <shell command>",
        "notes": "notes [<filename]",
        "exploit": "exploit <http:|ftp:|filename>",
        "ed": "ed <env/file",
        "svr": "svr <host> <port>",
        "exit": "exit [<web svr>]",
        "quit": "quit [<web svr>]"
      }
      
      try:
        print details[cmd]
        return
      except:
        pass

    print """
General
-------

  Command   Description  
  -------   -----------
  show      Show data connected to the machine and environment.
  scan      Execute a given shell command and store the results.
  notes     Open editor to take notes for selected machine.
  exploit   Store a given exploit by either URL or just create file in exploit directory.
  ed        Edit any path within the selected machine.
  quit      Exit the tool
  exit      Synonymous with quit

Machine Selection
-----------------

  Command   Description  
  -------   -----------

  machine   Set the active machine (IP address)
  network   Set the active network (e.g public)
  go        Jump to a given machine

Tag Management
--------------

  Command   Description  
  -------   -----------
  tag       Add a tag for a given machine
  rtag      Remove a tag for a given machine
  find      Find known machines with a given tag 

Server Management
-----------------

  Command   Description  
  -------   -----------
  svr       Spin up a temporary web server
"""
  
  def do_exit(self, args):

    if len(args) == 0:
      raise ExitApplicationException()
    if args[0]:
      if args[0] in self.web_server:
        self.web_server[args[0]]['instance'].shutdown()
        del self.web_server[args[0]]
      else:
        print "No such instance"

  def do_machine(self, machine):
    self.settings.machine = machine

    self.do_machine_init()

  def do_network(self, network):
    self.settings.network = network

    path = "{}/{}".format(self.settings.pwd, network)

    if not os.path.isdir(path):
      os.makedirs(path)

  def do_web_server(self, ipaddr, port):
    entered_server_dir = raw_input("Web server dir: ")

    os.chdir(entered_server_dir)
    server = SimpleHTTPServer.SimpleHTTPRequestHandler
    httpd = SocketServer.TCPServer((ipaddr, port), server)

    thread = threading.Thread(target = httpd.serve_forever)
    thread.daemon = True
    
    thread.start()

    serverName = "web-{}".format(len(self.web_server)+1)
    url = "http://{}:{}".format(ipaddr, port)

    self.web_server[serverName] = {
      "instance": httpd,
      "url": url
    }

    print "Server now running on {} with name {}".format(url, serverName)

  def do_show(self, args):
    for arg in args:
      if arg == "loot":
        for f in os.listdir(self.path_gen("loot")):
          print f
      elif arg == "scan":
        for f in os.listdir(self.path_gen("scan")):
          with open(self.path_gen("scan/" + f)) as r:
            print r.read()
      elif arg == "notes":
        for f in os.listdir(self.path_gen("notes")):
          with open(self.path_gen("notes/" + f)) as r:
            print r.read()
      elif arg == "exploit":
        for f in os.listdir(self.path_gen("exploit")):
          print f
      elif arg == "settings":
        print json.dumps(vars(self.settings), indent=3)
      elif arg == "networks":
        for f in os.listdir(self.path_gen("../../")):
          print f
      elif arg == "machines":
        for f in os.listdir(self.path_gen("../")):
          if os.path.isdir(f):
            print f
      elif arg == "files":
        for root, dirs, files in os.walk(self.path_gen(".")):
          path = root.split(os.sep)
          basename = os.path.basename(root)
        
          if basename == ".": continue

          print basename
          for file in files:
            print " " * 2 + file
      elif arg == "tags":
        r = self.env.execute("SELECT tag, value FROM tag_map m LEFT JOIN tags t ON m.tag_id = t.id WHERE network = ? AND machine = ?",
          [self.settings.network, self.settings.machine]
        )

        for row in r:
          print "{} => {}".format(row[0], row[1])
      elif arg == "svr":
        for key, value in self.web_server.iteritems():
          print "{} => {}".format(key, value['url'])

  def do_machine_init(self):
    dirs = ["loot", "scan", "notes", "exploit"]

    # Create directory structure
    for d in dirs:
      path = self.path_gen(d)

      if os.path.exists(path):
        continue

      self.debug("Creating {}".format(str(path)))
      os.makedirs(path)

  def do_tag_add(self, name, value):
    c = self.env.cursor()

    tag_exists = c.execute("SELECT id FROM tags WHERE tag = ?", (name,)).fetchone()

    if not tag_exists:
      tag_id = c.execute("INSERT INTO tags (tag) VALUES (?)", (name,)).lastrowid
    else:
      tag_id = tag_exists[0]

    c.execute("INSERT INTO tag_map (network, machine, tag_id, value) VALUES (?, ?, ?, ?)", 
      (self.settings.network, self.settings.machine, tag_id, value)
    )

    self.env.commit()

  def do_tag_remove(self, name):
    c = self.env.cursor()

    r = c.execute("SELECT id FROM tags WHERE tag = ?", [name,]).fetchone()
    c.execute("DELETE FROM tag_map WHERE tag_id = ? AND network = ? AND machine = ?",
      [r[0], self.settings.network, self.settings.machine]
    )

    self.env.commit()

  def do_tag_find(self, tag):
    if "=" in tag:
      (tag, value) = tag.split("=")
      r = self.env.execute("SELECT network, machine FROM tag_map m LEFT JOIN tags t ON m.tag_id = t.id WHERE t.tag = ? AND value = ?", (tag, value))
    else:
      r = self.env.execute("SELECT network, machine FROM tag_map m LEFT JOIN tags t ON m.tag_id = t.id WHERE t.tag = ?", (tag,))

    idx = 0

    for row in r:
      self.found.append([row[0], row[1]])

      print "[{}] {}".format(idx, "{}/{}".format(row[0], row[1]))
      idx += 1

  def do_go(self, search):
    if(search.isdigit()):
      idx = int(search)
      if idx >= 0 and idx <= len(self.found)-1:
        self.do_network(self.found[idx][0])
        self.do_machine(self.found[idx][1])
    elif "/" in search:
      (network, machine) = search.split("/")

      self.do_network(network)
      self.do_machine(machine)
    else:
      self.do_machine(search)

  def do_exploit(self, exploit):
    if exploit.startswith("http://") or exploit.startswith("https://"):
      src = requests.get(exploit).text
      with open(self.path_gen("exploit/" + os.path.basename(exploit)), "w") as f:
        f.write(src)
        
    elif exploit.startswith("ftp://"):
      pass

  def do_edit(self, selected):
    path = self.path_gen(selected)

    self.command_runner.execute(ShellCommand([self.settings.editor, path], interactive=True))
    
  def do_sh_scan(self, command):
    scan_name = self.cmd_to_filename(command)

    if "{}" not in command:
      command += " " + self.settings.machine
    else:
      command = command.replace("{}", self.settings.machine)

    path = self.path_gen("scan/" + scan_name) + ".txt"

    command = ShellCommand(command, output=path, interactive=False) 
    self.command_queue.put(command)

  def do_notes(self, args):
    if args:
      filename = "notes/" + args[0]
    else:
      filename = "notes/general.md"

    self.do_edit(filename)

  def debug(self, msg):
    if self.settings.debug:
      print msg

  def get_settings(self):
    return self.settings

  def path_gen(self, selected):
     return "{}/{}/{}/{}".format(
      self.settings.pwd, 
      self.settings.network,
      self.settings.machine,
      selected)

  def cmd_to_filename(self, command):
    return re.sub(r'[^a-zA-Z0-9]+', "-", command)

  def process_command(self, cmd):
    if not cmd:
      return

    cmds = {
      "help": lambda cmd, args : self.do_help(args[0]),
      "machine": lambda cmd, args : self.do_machine(args[0]),
      "network": lambda cmd, args : self.do_network(args[0]),
      "show": lambda cmd, args : self.do_show(args),
      "notes": lambda cmd, args : self.do_notes(args),
      "exploit": lambda cmd, args : self.do_exploit(args[0]),
      "svr": lambda cmd, args : self.do_web_server(args[0], int(args[1])),
      "tag": lambda cmd, args : self.do_tag_add(args[0], args[1]),
      "rtag": lambda cmd, args : self.do_tag_remove(args[0]),
      "find": lambda cmd, args : self.do_tag_find(args[0]),
      "ed": lambda cmd, args : self.do_edit(args[0]),
      "go": lambda cmd, args : self.do_go(args[0]),
      "scan": lambda cmd, args : self.do_sh_scan(" ".join(args)),
      "exit": lambda cmd, args : self.do_exit(args),
      "quit": lambda cmd, args : self.do_exit(args)
    }

    cmd_split = cmd.split()
    try:
      execute = cmds.get(cmd_split[0])
      execute(cmd_split[0], cmd_split[1:])
    except ExitApplicationException:
      raise
    except Exception as e:
      self.debug(str(e))
      self.do_help()

def header():
    print """
,---.          --.--          |        --.--          |
|---',---.,---.  |  ,---.,---.|---       |  ,---.,---.|
|    |---'|   |  |  |---'`---.|          |  |   ||   ||    
`    `---'`   '  `  `---'`---'`---'      `  `---'`---'`---'

Author: Ed Cradock
Version: 0.1
"""

def setup_env(settings):
  conn = sqlite3.connect("{}/.env.db".format(settings.pwd))
  c = conn.cursor()

  c.execute("CREATE TABLE IF NOT EXISTS tags (id INTEGER PRIMARY KEY , tag TEXT)")
  c.execute("CREATE TABLE IF NOT EXISTS tag_map (network TEXT, machine TEXT, tag_id INTEGER, value TEXT)")

  conn.commit()

  return conn

def main():
  parser = argparse.ArgumentParser()
  parser.add_argument("-w", "--working-dir", help="Current working directory")
  parser.add_argument("-n", "--network", help="Network name")
  parser.add_argument("-m", "--machine", help="Machine name")
  parser.add_argument("-d", "--debug", help="Enable debug messages", const=True, default=False, nargs="?")
  parser.add_argument("-e", "--editor", help="Editor")

  args = parser.parse_args()
  settings = Settings()

  editor_env = os.getenv("EDITOR")

  if args.network:
    settings.network = args.network

  if args.machine:
    settings.machine = args.machine

  if args.debug:
    settings.debug = args.debug

  if args.working_dir:
    settings.pwd = args.working_dir
  else:
    settings.pwd = os.getcwd()

  if args.editor:
    settings.editor = args.editor
  elif editor_env:
    settings.editor = editor_env

  header()
  env = setup_env(settings)
  output = []

  command_runner = ShellCommandRunner(ShellCommandRunner.SUBPROCESS, output)
  commands = Commands(settings, env, command_runner)
  
  while 1:
    s = raw_input("{}/{} > ".format(settings.network, settings.machine))

    try:
      commands.process_command(s)

      settings = commands.get_settings()
    except ExitApplicationException as e:
      return 

if __name__ == "__main__":
  main()
